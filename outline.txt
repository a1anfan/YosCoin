-- Encryption (use hashlib) --
verifySig(pubKey, msg, sig) -> bool
sign(privKey, msg) -> sig
genKeys() -> privKey, pubKey (Python tuple)

-- Block Class --

Class constant

Instance vars:
  prevHash
  coinBase
  txs
  nonce
  difficulty

__init__(prevHash, coinbaseRecipient, txs, nonce, difficulty)
  self.txs = txs
  self.txs.append(coinBaseTractions)

Instance methods:
  hash

-- UTXOPool --
Instance vars
  txOuts[]
  
Instance methods
  handleTxs(txList) -> bool (if valid && successful)
  verifyTxs(txList) -> bool (if valid)
  clone() -> UTXOPool

__init__() -> creates empty UTXOPool

-- Transaction --
Instance vars
  txIns[]
  txOuts[]
  hash

__init__(txIns, txOuts)

sign(privKey, inputIndex)

-- TxIn --
Instance vars
  prevTxHash
  prevTxOutIndex
  signature

__init__(id, index)

-- TxOut --
Instance vars
  address
  value

__init__(address, value)

-- Blockchain Class ---
Class method:
  fromJSON(str) -> BC

Instance vars:
  blocks
  utxoPool

Instance methods:
  toJSON() -> str
  addBlock(block) -> calls verifyBlock then updates chain
  mineForBlocks(pendingTxs) ->
    # __init__(prevHash, coinbaseRecipient, txs, nonce, difficulty)
    difficulty = 5 #hard-coded, subject to change
    attempts = 0
    while True:
      attemptBlock = Block( blocks[-1].hash(), ME, txs, random(), difficulty )
      if attemptBlock.hash.leadingZeros >= difficulty
        return attemptBlock
      attempts++ 

__init__() -> creates genesis block with no coinbase or outputs

-- Main --
myBC = new BC()

thread 1 always mines:
  myBC.mineForNewBlock()

thread 2 listens for other BCs:
  if(otherBC.height > myBC.height)
    myBC = otherBC

other networking threads...